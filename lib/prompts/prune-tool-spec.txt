Prunes tool outputs from context to manage conversation size and reduce noise. For `write` and `edit` tools, the input content is pruned instead of the output.

## IMPORTANT: The Prunable List
A `<prunable-tools>` list is injected into user messages showing available tool outputs you can prune when there are tools available for pruning. Each line has the format `ID: tool, parameter` (e.g., `20: read, /path/to/file.ts`). You MUST only use numeric IDs that appear in this list to select which tools to prune.

**Note:** For `write` and `edit` tools, pruning removes the input content (the code being written/edited) while preserving the output confirmation. This is useful after completing a file modification when you no longer need the raw content in context.

## CRITICAL: When and How to Prune

You must use this tool in three specific scenarios. The rules for distillation (summarizing findings) differ for each. **You must specify the reason as the first element of the `ids` array** to indicate which scenario applies.

### 1. Task Completion (Clean Up) — reason: `completion`
**When:** You have successfully completed a specific unit of work (e.g., fixed a bug, wrote a file, answered a question).
**Action:** Prune the tools used for that task.
**Distillation:** NOT REQUIRED. Since the task is done, the raw data is no longer needed. Simply state that the task is complete.

### 2. Removing Noise (Garbage Collection) — reason: `noise`
**When:** You have read files or run commands that turned out to be irrelevant, unhelpful, or outdated (meaning later tools have provided fresher, more valid information).
**Action:** Prune these specific tool outputs immediately.
**Distillation:** FORBIDDEN. Do not pollute the context by summarizing useless information. Just cut it out.

### 3. Context Conservation (Research & Consolidation) — reason: `consolidation`
**When:** You have gathered useful information. Prune frequently as you work (e.g., after reading a few files), rather than waiting for a "long" phase to end.
**Action:** Convert raw data into distilled knowledge. This allows you to discard large outputs (like full file reads) while keeping only the specific parts you need (like a single function signature or constant).
**Distillation:** MANDATORY. Before pruning, you *must* explicitly summarize the key findings from *every* tool you plan to prune.
   - **Extract specific value:** If you read a large file but only care about one function, record that function's details and prune the whole read.
   - Narrative format: "I found X in file Y..."
   - Capture all relevant details (function names, logic, constraints).
   - Once distilled into your response history, the raw tool output can be safely pruned.
   - **Know when distillation isn't enough:** If you'll need to edit a file, grep for exact strings, or reference precise syntax, keep the raw output. Distillation works for understanding; implementation often requires the original.
   - **Prefer keeping over re-fetching:** If uncertain whether you'll need the output again, keep it. The cost of retaining context is lower than the cost of redundant tool calls.

## Best Practices
- **Consolidate your prunes:** Don't prune a single small tool output (like a short bash command) unless it's pure noise. Wait until you have several items or a few large outputs to prune. Aim for high-impact prunes that significantly reduce context size or noise.
- **Don't wait too long:** Prune frequently to keep the context agile, but balance this with the need for consolidation.
- **Be surgical:** You can mix strategies. Prune noise without comment, while distilling useful context in the same turn.
- **Verify:** Ensure you have captured what you need before deleting useful raw data.
- **Think ahead:** Before pruning, ask: "Will I need this output for an upcoming task?" If you researched a file you'll later edit, or gathered context for implementation, do NOT prune it—even if you've distilled findings. Distillation captures *knowledge*; implementation requires *context*.

## Examples

<example_noise>
Assistant: [Reads 'wrong_file.ts']
This file isn't relevant to the auth system. I'll remove it to clear the context.
[Uses prune with ids: ["noise", "5"]]
</example_noise>

<example_consolidation>
Assistant: [Reads 5 different config files]
I have analyzed the configuration. Here is the distillation:
- 'config.ts' uses port 3000.
- 'db.ts' connects to mongo:27017.
- The other 3 files were defaults.
I have preserved the signals above, so I am now pruning the raw reads.
[Uses prune with ids: ["consolidation", "10", "11", "12", "13", "14"]]
</example_consolidation>

<example_completion>
Assistant: [Runs tests, they pass]
The tests passed. The feature is verified.
[Uses prune with ids: ["completion", "20", "21"]]
</example_completion>

<example_keep>
Assistant: [Reads 'auth.ts' to understand the login flow]
I've understood the auth flow. I'll need to modify this file to add the new validation, so I'm keeping this read in context rather than distilling and pruning.
</example_keep>

<example_edit_completion>
Assistant: [Edits 'auth.ts' to add validation]
The edit was successful. I no longer need the raw edit content in context.
[Uses prune with ids: ["completion", "15"]]
</example_edit_completion>
