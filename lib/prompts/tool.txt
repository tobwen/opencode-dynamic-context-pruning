Prunes tool outputs from context to manage conversation size and reduce noise.

## IMPORTANT: The Prunable List
A `<prunable-tools>` list is injected into user messages showing available tool outputs you can prune. Each line has the format `ID: tool, parameter` (e.g., `20: read, /path/to/file.ts`). Use these numeric IDs to select which tools to prune.

## CRITICAL: When and How to Prune

You must use this tool in three specific scenarios. The rules for distillation (summarizing findings) differ for each. **You must specify the reason as the first element of the `ids` array** to indicate which scenario applies.

### 1. Task Completion (Clean Up) — reason: `completion`
**When:** You have successfully completed a specific unit of work (e.g., fixed a bug, wrote a file, answered a question).
**Action:** Prune the tools used for that task.
**Distillation:** NOT REQUIRED. Since the task is done, the raw data is no longer needed. Simply state that the task is complete.

### 2. Removing Noise (Garbage Collection) — reason: `noise`
**When:** You have read files or run commands that turned out to be irrelevant, unhelpful, or outdated (meaning later tools have provided fresher, more valid information).
**Action:** Prune these specific tool outputs immediately.
**Distillation:** FORBIDDEN. Do not pollute the context by summarizing useless information. Just cut it out.

### 3. Context Conservation (Research & Consolidation) — reason: `consolidation`
**When:** You have gathered useful information. Prune frequently as you work (e.g., after reading a few files), rather than waiting for a "long" phase to end.
**Action:** Convert raw data into distilled knowledge. This allows you to discard large outputs (like full file reads) while keeping only the specific parts you need (like a single function signature or constant).
**Distillation:** MANDATORY. Before pruning, you *must* explicitly summarize the key findings from *every* tool you plan to prune.
   - **Extract specific value:** If you read a large file but only care about one function, record that function's details and prune the whole read.
   - Narrative format: "I found X in file Y..."
   - Capture all relevant details (function names, logic, constraints).
   - Once distilled into your response history, the raw tool output can be safely pruned.

## Best Practices
- **Don't wait too long:** Prune frequently to keep the context agile.
- **Be surgical:** You can mix strategies. Prune noise without comment, while distilling useful context in the same turn.
- **Verify:** Ensure you have captured what you need before deleting useful raw data.

## Examples

<example_noise>
Assistant: [Reads 'wrong_file.ts']
This file isn't relevant to the auth system. I'll remove it to clear the context.
[Uses prune with ids: ["noise", 5]]
</example_noise>

<example_consolidation>
Assistant: [Reads 5 different config files]
I have analyzed the configuration. Here is the distillation:
- 'config.ts' uses port 3000.
- 'db.ts' connects to mongo:27017.
- The other 3 files were defaults.
I have preserved the signals above, so I am now pruning the raw reads.
[Uses prune with ids: ["consolidation", 10, 11, 12, 13, 14]]
</example_consolidation>

<example_completion>
Assistant: [Runs tests, they pass]
The tests passed. The feature is verified.
[Uses prune with ids: ["completion", 20, 21]]
</example_completion>
